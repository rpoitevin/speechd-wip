Speech Dispatcher TODO
======================

The release versions are not final, and could change. Targetted release is 
based on demand from users, and difficulty of the work involved.

 (0.9) Migrate to GSettings.
 (0.9) Synthesizer specific settings API.
 (0.10) Use more GLib in the server.
 (0.10) Move audio into server.
 (0.10) Client audio retrieval API.
 (0.9) Server to module protocol documentation.
 (0.11) Server to module protocol improvements.
 * Move synth modules to plugin architecture with plugin host.
 * Synth plugin API.
 * Allow for building synth plugins out of tree.
 (0.10) Integrate with logind/consolekit.
 (0.9) Properly support system-wide mode.
 * Support spawning the server via Systemd socket activation.


The above improvements are documented in detail below. If work has started on 
a particular project, a git branch will be noted. These git branches are 
located at https://github.com/TheMuso/speechd-wip.git. To read the most up to 
date copy of this file, please clone the master Speech Dispatcher git 
repository, located at git://git.freebsoft.org/git/speechd.gitand check out 
the master branch.

Migrate to GSettings
--------------------

 * Write the GSettings metadata XML file.
 * Migrate the server to GSettings.
 * Listen to GSettings changes.
 * Migrate synthesizer modules to GSettings.
 * Write a program to migrate user settings to GSettings.
 * Write a configuration tool so that users can change speechd settings other than via the gsettings command-line.

The configuration tool needs a way to discover available modules, particularly since there is a desire to support 3rd-party modules in the future, and this has to work accross the various next generation packaging/environment sandboxing systems, i.e snappy and flatpack. Exactly how 3rd-party modules will work when confined in these systems is to be worked out later, but we should try and work out the best solution for module discovery now, so that the amount of work to allow the configuration tool to find sandboxed 3rd-party modules in the future is minimal.

 * Modules need to be discoverable via GSettings. The GSettings key should probably be an array of strings, with each string pointing to a metadata file that provides information about the module. The metadata file will be in GLib's key file format, i.e ini-like, something like the following.

[general]
name=ESpeak
description=The ESpeak Speech Synthesizer
module-binary=/path/to/binary (May change later when 3rd-party module support/out of tree module building is developed.)
confinement=snap/flatpack (again once support for these systems is added, but planning ahead.)
schemas=com.example.synth:com.example.synth.something
relocatable-schemas=com.example.synth.something-else:com.example.synth.user-specific

[com.example.synth.something-else]
schema-path-template=/com/example/synth/language/%s
template-key=com.example.synth:languages
...

The above should be explanetory, except maybe for template-key. I couldn't think of a better term, but it points to the key where relevant information is stored to be substituted in the schema path template string.

The config tool would use the GSettingsSchema API to walk the schemas, extracting text for the summary and description, which would be shown in the UI. The value type can then be used as a hint as to the type of data that the user is expected to enter. Unfortunately I haven't yet determined the best way to show enum values.

The above could also be extended to provide hints as to how to show the data from a particular relocatable schema, i.e table form, list form, etc.


Synthesizer specific settings API
Depends on: Migration to GSettings
---------------------------------

Background:
 * Currently have API for espeak pitch range in git master, but this is only 
   useful for espeak.
 * Espeak module has a config option to show variants along with available 
   voices, which can be a very long list and can choak some clients.

 * Implement server to module protocol to support:
   - Request available settings.
   - Request available settings and their current value.
   - Request the value of a setting.
   - Set a setting.
   - Reset a setting to its default.
 * Implement SSIP protocol support.
 * Implement C API, see synthesizer specific settings C API draft.
 * Implement python API.

Synthesizer specific settings C API draft

typedef struct {
        char *name;
        char *description; /* This should be localized */
        enum SynthSettingValueType get_type;
        enum SynthSettingValueType set_type;
        int min_value;
        int max_value;
        char **value_list;
        void *cur_value;
] SynthSetting;

In the C API, a NULL terminated array of this structure would be returned for 
all settings a synth offers.

The SynthSettingValueType enum would look something like this:

typedef enum {
        SYNTH_SETTING_VALUE_UNKNOWN = 0,
        SYNTH_SETTING_VALUE_NUMBER = 1,
        SYNTH_SETTING_VALUE_STRING = 2,
        SYNTH_SETTING_VALUE_STRING_LIST = 3 /* A list of strings for the user 
                                               to choose from, i.e voice variants */
} SynthSettingValueType;

C API methods to work with these data types could be as follows:

SynthSetting **spd_synth_get_settings(SPDConnection *connection);
int spd_synth_set_setting(SPDConnection *connection, SynthSetting *setting, 
void *value);
void free_synth_settings(SynthSettings **settings);


Use more GLib in the server
---------------------------

 * Use GLib event loops where possible.
 * use GLib GThreads and GAsyncQueues for thread communication.
 * Use g_spawn calls for executing modules.
 * Support multiple client connection methods, unix socket, inet socket.
 * Use g_debug and other relevant GLib logging facilities for 
   messages/logging.
 * Use GThreadedSocketService for handling client connections.
 * Replace custom implementations of parsing buffers with GLib equivalent 
   methods where possible.


Move audio into server
----------------------

 * Extend the server to module protocol to receive audio from modules.
 * Consider using a separate socket for audio transfer, however this may be 
   difficult when attempting to synchronise with index marks. An alternative is 
   to send index mark data via the audio socket as well.
 * Implement a playback queue supporting the following types:
   (The Espeak module is a good reference)
   - Begin event
   - End event
   - Index mark event
   - Audio event
   - Sound icon event
 * Rework modules supporting audio output to not use any advanced internal 
   playback queueing, and simply send the audio in relatively small buffers to 
   the server. Smaller buffers to allow the server to stop/pause the audio more 
   responsively.
 * Implement a mechanism to allow modules to signal that they do not support 
   audio output.
 * Support multiple clients using different audio output devices on the one 
   backend.
 * Extend priority system to be either global priority, or priority per audio 
   output device.
 * Run audio in separate thread, possibly using 2 threads, a controller 
   thread, and a playback thread, one playback thread per audio device. Again, 
   the espeak module does something similar.
 * Rework pulseaudio output to use a GLib event loop.
 * Rework other audio output modules to better work within an event loop.


Client audio retrieval API
--------------------------

 * Allow client to either request audio directly, or have audio written to a 
   designated file on disk.
 * Allow modules to decline the use of direct audio retrieval. I know of one 
   speech synth that is not supported by speech dispatcher, who's licensing 
   model doesn't allow for direct audio retrieval. If this module is ever 
   supported, its code will likely remain closed to prevent people working 
   around the implementation, but it would still be nice to support this synth 
   in the longer term. (Luke Yelavich)
 * Load a new instance of the requested synth module, and spin up a worker 
   thread to handle audio file writing or sending to client, to allow the server 
   to dispatch other speech messages, as direct audio retrieval should be 
   independant of the priority system.


Server to module protocol documentation
---------------------------------------

* Similar to the SSIp documentation, write up a texi document that explains 
  the server to module protocol, currently over stdin/stdout, but may use other 
  IPC in the future.


Server to module protocol improvements
--------------------------------------

 * Consider using sockets for IPC, with a dedicated socket per module.
 * Consider implementing shared memory support, particularly for audio data 
   transfer, but this may depend on whether GLib has a shared memory API, The 
   GMappedFile API may be useful, if the initiator can change the contents of 
   the GMappedFile, and the other side can notice changes. Needs investigation.
 * Support the launching of modules via systems other than Speech Dispatcher, 
   useful where containers of some sort are being used, and the environment 
   requires that any separate processes are run in containers/other kind of 
   sandbox, hense the use of sockets as per above.


Integrate with logind/consolekit
(Depends on migration to GSettings, GLib main event loops everywhere)
--------------------------------

 * Query current user, and currently running sessions for that user.
 * Subscribe to tty change events and cork audio playback and synthesis flow 
   if none of the user's sessions are active.
 * Allow the enabling/disabling of logind/consolekit via GSettings and at 
   runtime, enabled being the default.
 * Allow the disabling of consolekit/logind at build time.
 * Consider abstracting this functionality into plugins, or at the very least 
   separate code with an internal API to more easily support any future 
   session/seat monitoring systems.


Properly support system-wide mode
---------------------------------

 * Set a default user and group for the system wide instance to run under, at 
   build time, and runtime.
 * Add a systemd unit to allow the use of system wide mode, disabled by 
   default.


Support spawning the server via Systemd socket activation
---------------------------------------------------------

 * Allow this to be enabled/disabled at build time.
